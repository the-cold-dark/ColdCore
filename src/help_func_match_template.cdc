
new object $help_func_match_template: $help_funcs_str;

var $has_name name = ['prop, "match_template()", "match_template()"];
var $help_node body = <$ctext_frob, [[<$format, ["dfn", [], [<$format, ["tt", [], [<$format, ["i", [], ["LIST"], 'do_i]>, " match_template(", <$format, ["i", [], ["STRING string"], 'do_i]>, ", ", <$format, ["i", [], ["STRING template"], 'do_i]>, ")"], 'do_tt]>], 'do_dfn]>, <$format, ["p", [], [], 'do_p]>, "This function matches the template ", <$format, ["i", [], ["template"], 'do_i]>, " against the command ", <$format, ["i", [], ["string"], 'do_i]>, ". The return value of ", <$format, ["tt", [], ["match_template()"], 'do_tt]>, " is a list of fields resulting from the template match, or ", <$format, ["tt", [], ["0"], 'do_tt]>, " if the match fails or if ", <$format, ["i", [], ["template"], 'do_i]>, " is an invalid template. ", <$format, ["np", [], [], 'do_np]>, "General information on matching can be found in the section ", <$format, ["link", [["node", "$help_commands_matching"]], ["Matching Conventions"], 'do_link]>, ". Templates are composed of ", <$format, ["i", [], ["word-patterns"], 'do_i]>, " and ", <$format, ["i", [], ["wildcards"], 'do_i]>, ". ", <$format, ["i", [], ["Word-patterns"], 'do_i]>, " may contain a mix of the ", <$format, ["i", [], ["partial-match"], 'do_i]>, " operator and the ", <$format, ["i", [], ["or"], 'do_i]>, " operator. ", <$format, ["np", [], [], 'do_np]>, "A ", <$format, ["i", [], ["word-pattern"], 'do_i]>, " is any sequence of characters bounded by spaces, or the beginning or end of the string. The pattern may include a question mark (", <$format, ["tt", [], ["'?'"], 'do_tt]>, "), which is the ", <$format, ["i", [], ["partial-match"], 'do_i]>, " operator; or it may include any number of pipe characters (", <$format, ["tt", [], ["'|'"], 'do_tt]>, "), which is the ", <$format, ["i", [], ["or"], 'do_i]>, " operator. The result from a word-pattern match is the string which matched the word-pattern. ", <$format, ["np", [], [], 'do_np]>, "The ", <$format, ["i", [], ["partial-match"], 'do_i]>, " operator is used to indicate that partial matches that extend at least as far as the question mark are ok. For instance, the ", <$format, ["i", [], ["word-pattern"], 'do_i]>, " ", <$format, ["tt", [], ["\"ex?am\""], 'do_tt]>, " matches any of the words ", <$format, ["tt", [], ["\"ex\""], 'do_tt]>, ", ", <$format, ["tt", [], ["\"exa\""], 'do_tt]>, " and ", <$format, ["tt", [], ["\"exam\""], 'do_tt]>, ". ", <$format, ["np", [], [], 'do_np]>, "The ", <$format, ["i", [], ["or"], 'do_i]>, " operator is used to group more than one word where any of the words in the group can be matched as one word. For instance, the template ", <$format, ["tt", [], ["\"this|that|there\""], 'do_tt]>, " would match ", <$format, ["tt", [], ["\"this\""], 'do_tt]>, " ", <$format, ["i", [], ["OR"], 'do_i]>, " ", <$format, ["tt", [], ["\"that\""], 'do_tt]>, " ", <$format, ["i", [], ["OR"], 'do_i]>, " ", <$format, ["tt", [], ["\"there\""], 'do_tt]>, ". ", <$format, ["np", [], [], 'do_np]>, <$format, ["i", [], ["Wildcards"], 'do_i]>, " can be either ", <$format, ["i", [], ["simple"], 'do_i]>, " or ", <$format, ["i", [], ["coupled"], 'do_i]>, ". A ", <$format, ["i", [], ["simple wildcard"], 'do_i]>, " is represented by an asterix (", <$format, ["tt", [], ["'*'"], 'do_tt]>, "). A simple wildcard matches any number of words in ", <$format, ["i", [], ["string"], 'do_i]>, ", and must be bounded by spaces or the beginning or end of the template. If the wildcard is followed in the template by a word-pattern, then it can also match a ", <$format, ["i", [], ["quoted wildcard match"], 'do_i]>, ". ", <$format, ["np", [], [], 'do_np]>, "A quoted wildcard match is just like a ColdC string literal: it begins and ends with a double quote (", <$format, ["tt", [], ["'\"'"], 'do_tt]>, "), and can include a literal double quote or backslash by preceding the character with a backslash (", <$format, ["tt", [], ["'\'"], 'do_tt]>, "). If the simple wildcard is followed by a word-pattern, and the words in ", <$format, ["i", [], ["string"], 'do_i]>, " that the wildcard would match begin with a double quote, then the match must be a quoted wildcard match or the match fails, even if the match would have succeeded if the words were not treated as a quoted wildcard match. However, if the words that the wildcard would match begin with a backslash followed by a double quote, then the backslash is ignored and the double quote and the text following it are treated as regular words. ", <$format, ["np", [], [], 'do_np]>, "The following template using a ", <$format, ["i", [], ["simple wildcard"], 'do_i]>, " ", <$format, ["tt", [], ["\"* bar\""], 'do_tt]>, " matches any of the following strings:", <$format, ["p", [], [], 'do_p]>, <$format, ["dfn", [], [<$format, ["tt", [], ["foo bar", <$format, ["br", [], [], 'do_br]>, "foo baz bar", <$format, ["br", [], [], 'do_br]>, "\"foo bar \" baz\" bar", <$format, ["br", [], [], 'do_br]>, "\"foo baz bar"], 'do_tt]>], 'do_dfn]>, <$format, ["p", [], [], 'do_p]>, "Matching against a simple wildcard produces one result per wildcard--the words that the simple wildcard matched. If the wildcard matches a quoted wildcard match, then the beginning and ending double quotes are stripped out of the result, as well as any backslashes used to escape characters inside the double quotes. ", <$format, ["np", [], [], 'do_np]>, "A ", <$format, ["i", [], ["coupled wildcard"], 'do_i]>, " is represented by the three-character sequence ", <$format, ["tt", [], ["'*=*'"], 'do_tt]>, ". It matches any sequence of words containing an equal sign (", <$format, ["tt", [], ["'='"], 'do_tt]>, "), and results in two strings, the text before the equal sign and the text after it. Any spaces surrounding the equal sign in the matched string are ignored and do not show up in the results. The text before the equal sign can be a quoted wildcard match (as before, if it begins with a double quote, then it must be a quoted wildcard match or the match fails, unless the initial double quote is escaped by a backslash). If the coupled wildcard is followed by a word pattern, then the text after the equal sign can also be a quoted wildcard match. The coupled wildcard is a special feature intended for parsing TinyMUD command formats. ", <$format, ["np", [], [], 'do_np]>, " Examples:", <$format, ["p", [], [], 'do_p]>, <$format, ["dfn", [], ["match_template(\"@descr me as foobar\", \"@desc?ribe * as *\")", <$format, ["br", [], [], 'do_br]>, "=> [\"@descr\", \"me\", \"as\", \"foobar\"]"], 'do_dfn]>, " ", <$format, ["dfn", [], ["match_template(\"@desc \\\"as is\\\" as foobar\", \"@desc?ribe * as *\")", <$format, ["br", [], [], 'do_br]>, "=> [\"@desc\", \"as is\", \"as\", \"foobar\"]"], 'do_dfn]>, " ", <$format, ["dfn", [], ["match_template(\"@desc \\\"as\\\" is as foobar\", \"@desc?ribe * as *\")", <$format, ["br", [], [], 'do_br]>, "=> 0"], 'do_dfn]>, " ", <$format, ["dfn", [], ["match_template(\"@desc \\\"as\" is as foobar\", \"@desc?ribe * as *\")", <$format, ["br", [], [], 'do_br]>, "=> [\"@desc\", \"\\\"as\\\" is\", \"as\", \"foobar\"]"], 'do_dfn]>, " ", <$format, ["dfn", [], ["match_template(\"@descr me =foobar\", \"@desc?ribe *=*\")", <$format, ["br", [], [], 'do_br]>, "=> [\"@descr\", \"me\", \"foobar\"]"], 'do_dfn]>, " ", <$format, ["dfn", [], ["match_template(\"@desc \"2+2=4\"= an equation\", \"@desc?ribe *=*\")", <$format, ["br", [], [], 'do_br]>, "=> [\"@desc\", \"2+2=4\", \"an equation\"]"], 'do_dfn]>, " ", <$format, ["dfn", [], ["match_template(\"look at rose\", \"l?ook|ex?amine *\")", <$format, ["br", [], [], 'do_br]>, "=> [\"look\", \"at rose\"]"], 'do_dfn]>], #[['this, $help_func_match_template]]]>;
var $help_node index = $help_index_function;
var $help_node links = #[["Matching Conventions", $help_commands_matching]];
var $help_node nolist = 0;
var $root created_on = 855384457;
var $root flags = ['variables, 'methods, 'code, 'core];
var $root inited = 1;
var $root managed = [$help_func_match_template];
var $root manager = $help_func_match_template;


