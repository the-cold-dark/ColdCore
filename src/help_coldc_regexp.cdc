
new object $help_coldc_regexp: $help_coldc_imp;

var $has_name name = ['prop, "Regexps|Regular Expressions", "Regexps|Regular Expressions"];
var $help_node body = <$ctext_frob, [[<$format, ["p", [], [], 'do_p]>, "ColdC Regular Expressions use Henry Spencer's Regular Expression package with further extensions similar to those Perl has implemented. ", <$format, ["np", [], [], 'do_np]>, "A Regular Expression is an abstract way of matching text. The simplest Regular Expression is a direct match. For instance, the string \"that\" exists within the string \"this and that are here.\", therefore \"that\" is a Regular Expression. ", <$format, ["np", [], [], 'do_np]>, "However, regular expressions can be much more complex than this case, as there are many possibilities which may be matched in strings. Wildcard matching is a common way of matching more than a simple instance of text. Wildcard matching generally matches any number of anything where a ", <$format, ["tt", [], ["`*'"], 'do_tt]>, " is found in the wildcard. Although useful it does have its restrictions. Wildcard matching is not used in Regular Expressions because of its lack of control. ", <$format, ["np", [], [], 'do_np]>, "The following is a list of all possible special characters in a regular expression which have special meaning: ", <$format, ["dfn", [["nobound", 1], [" ", 1], ["ind", "4"]], [<$format, ["table", [["cols", "10%,90%"]], [<$format, ["tr", [], [<$format, ["td", [], [<$format, ["tt", [], ["\\"], 'do_tt]>], 'do_td]>, <$format, ["td", [], ["Escape Mechanism, changes the meaning of the next character"], 'do_td]>], 'do_tr]>, <$format, ["tr", [], [<$format, ["td", [], [<$format, ["tt", [], ["^"], 'do_tt]>], 'do_td]>, <$format, ["td", [], ["Match the beginning of a string, or if at the beginning of a range, logically inverts the value (i.e. anything NOT in this range)"], 'do_td]>], 'do_tr]>, <$format, ["tr", [], [<$format, ["td", [], [<$format, ["tt", [], ["$"], 'do_tt]>], 'do_td]>, <$format, ["td", [], ["Match the end of a string"], 'do_td]>], 'do_tr]>, <$format, ["tr", [], [<$format, ["td", [], [<$format, ["tt", [], ["|"], 'do_tt]>], 'do_td]>, <$format, ["td", [], ["Branch Seperator"], 'do_td]>], 'do_tr]>, <$format, ["tr", [], [<$format, ["td", [], [<$format, ["tt", [], ["()"], 'do_tt]>], 'do_td]>, <$format, ["td", [], ["Grouping"], 'do_td]>], 'do_tr]>, <$format, ["tr", [], [<$format, ["td", [], [<$format, ["tt", [], ["[]"], 'do_tt]>], 'do_td]>, <$format, ["td", [], ["Range"], 'do_td]>], 'do_tr]>, <$format, ["tr", [], [<$format, ["td", [], [<$format, ["tt", [], ["."], 'do_tt]>], 'do_td]>, <$format, ["td", [], ["Match any one character"], 'do_td]>], 'do_tr]>, <$format, ["tr", [], [<$format, ["td", [], [<$format, ["tt", [], ["*"], 'do_tt]>], 'do_td]>, <$format, ["td", [], ["Match zero or more of the previous"], 'do_td]>], 'do_tr]>, <$format, ["tr", [], [<$format, ["td", [], [<$format, ["tt", [], ["+"], 'do_tt]>], 'do_td]>, <$format, ["td", [], ["Match one or more of the previous"], 'do_td]>], 'do_tr]>, <$format, ["tr", [], [<$format, ["td", [], [<$format, ["tt", [], ["?"], 'do_tt]>], 'do_td]>, <$format, ["td", [], ["Match zero or one of the previous"], 'do_td]>], 'do_tr]>], 'do_table]>], 'do_dfn]>, " ", <$format, ["subj", [["level", "2"]], ["ColdC Regular Expressions Explained"], 'do_subj]>, <$format, ["p", [], [], 'do_p]>, "The first concept of Regular Expressions are ", <$format, ["i", [], ["branches"], 'do_i]>, ". There can be zero or more ", <$format, ["i", [], ["branches"], 'do_i]>, " in a Regular Expression, seperated by the pipe character (\"|\"). A Regular Expression will match anything in one of the branches. An example of this is:", <$format, ["p", [], [], 'do_p]>, <$format, ["dfn", [], [<$format, ["tt", [], ["this|that|there"], 'do_tt]>], 'do_dfn]>, <$format, ["p", [], [], 'do_p]>, "This Regular Expression will match \"this\" OR \"that\" OR \"there\". It is easiest to logically think of branches in this manner. ", <$format, ["np", [], [], 'do_np]>, "A branch is further defined as zero or more ", <$format, ["i", [], ["pieces"], 'do_i]>, " joined together. A ", <$format, ["i", [], ["piece"], 'do_i]>, " is an ", <$format, ["i", [], ["atom"], 'do_i]>, " possibly followed by an asterisk, a plus sign, or a question mark (\"*\", \"+\", or \"?\"). The asterisk, plus sign, or question mark defines how to match the atom. An atom followed by an asterisk matches zero or more occurances of the atom. An atom followed by a plus sign matches one or more occurances of the atom. An atom followed by a question mark matches zero or one occurance of the atom. ", <$format, ["np", [], [], 'do_np]>, "An ", <$format, ["i", [], ["atom"], 'do_i]>, " is either a Regular Expression Group or Range (see below), or one of the following: a period (\".\"), a carat (\"^\"), a dollar sign (\"$\"), a back-slash (\"\\\") followed by a single character, or a single character with no other significance. A period matches any single character in the input text, a carat matches the beginning of the input text, a dollar-sign matches the end of the input text, and a back-slash followed by a single character either has special significance--such as matching all white space or all digits--or it removes special significance from the following character. For instance, \"$\" would match a dollar-sign in the input text, rather than matching the end of the line (which is what the dollar-sign usually does). ", <$format, ["np", [], [], 'do_np]>, "A Group is anything enclosed within a set of parenthesis (", <$format, ["tt", [], ["\"()\""], 'do_tt]>, "). Groups will help to clarify how the Regular Expression should match, in addition to what results should be returned from the Regular Expression. If one or more groups exist, the result of the regular expression will include the groups, possibly in addition to the entire area matched in the string (what is returned will depend upon the function). ", <$format, ["np", [], [], 'do_np]>, "A range is a sequence of characters enclosed in square brackets (", <$format, ["tt", [], ["\"[]\""], 'do_tt]>, "). It normally matches any single character contained within the range sequence. Characters which normally have special significance (such as a dollar-sign, period and a back-slash) loose that significance when enclosed in a range. However, a range has its own special characters. If the range begins with a carat (", <$format, ["tt", [], ["\"^\""], 'do_tt]>, "), it matches any single character which is ", <$format, ["i", [], ["not"], 'do_i]>, " in the sequence. If two characters in the sequence are separated by a dash (", <$format, ["tt", [], ["\"-\""], 'do_tt]>, "), the full range of ASCII characters between the two are matched, including the two. For instance, ", <$format, ["tt", [], ["\"[0-9]\""], 'do_tt]>, " matches any single decimal digit from zero to nine. To include a literal square bracket (", <$format, ["tt", [], ["\"]\""], 'do_tt]>, ") in the sequence do not use the back-slash to escape it (as the back-slash does not have special meaning when in a range), instead place it at the begining of the range (following a possible ", <$format, ["tt", [], ["\"^\""], 'do_tt]>, "). To include a literal dash (", <$format, ["tt", [], ["\"-\""], 'do_tt]>, ") place it the start or end of the range. ", <$format, ["np", [], [], 'do_np]>, "Consider the following examples: ", <$format, ["dfn", [["nobound", 1], [" ", 1], ["ind", "4"]], [<$format, ["table", [["cols", "50%,50%"]], [<$format, ["tr", [], [<$format, ["td", [], [<$format, ["tt", [], ["a?"], 'do_tt]>], 'do_td]>, <$format, ["td", [], ["Match zero or one 'a' characters"], 'do_td]>], 'do_tr]>, <$format, ["tr", [], [<$format, ["td", [], [<$format, ["tt", [], ["(this|that)*"], 'do_tt]>], 'do_td]>, <$format, ["td", [], ["Match zero or more occurances of \"this\" or \"that\""], 'do_td]>], 'do_tr]>, <$format, ["tr", [], [<$format, ["td", [], [<$format, ["tt", [], ["[a-z]+"], 'do_tt]>], 'do_td]>, <$format, ["td", [], ["Match one or more occurances of any alphabetic character (a through z)"], 'do_td]>], 'do_tr]>, <$format, ["tr", [], [<$format, ["td", [], [<$format, ["tt", [], ["[^0-9]?"], 'do_tt]>], 'do_td]>, <$format, ["td", [], ["Match zero or one occurance of any non-digit character"], 'do_td]>], 'do_tr]>], 'do_table]>], 'do_dfn]>, <$format, ["p", [], [], 'do_p]>, "The following characters have special meaning when matching (similar to PERL Regular Expressions): ", <$format, ["dfn", [["nobound", 1], [" ", 1], ["ind", "4"]], [<$format, ["table", [["cols", "10%,90%"]], [<$format, ["tr", [], [<$format, ["td", [], ["\"\w\""], 'do_td]>, <$format, ["td", [], ["Match a word word character (alphanumeric plus \"_\")"], 'do_td]>], 'do_tr]>, <$format, ["tr", [], [<$format, ["td", [], ["\"\W\""], 'do_td]>, <$format, ["td", [], ["Match a non-word character"], 'do_td]>], 'do_tr]>, <$format, ["tr", [], [<$format, ["td", [], ["\"\s\""], 'do_td]>, <$format, ["td", [], ["Match a whitespace character"], 'do_td]>], 'do_tr]>, <$format, ["tr", [], [<$format, ["td", [], ["\"\S\""], 'do_td]>, <$format, ["td", [], ["Match a non-whitespace character"], 'do_td]>], 'do_tr]>, <$format, ["tr", [], [<$format, ["td", [], ["\"\d\""], 'do_td]>, <$format, ["td", [], ["Match a digit character"], 'do_td]>], 'do_tr]>, <$format, ["tr", [], [<$format, ["td", [], ["\"\D\""], 'do_td]>, <$format, ["td", [], ["Match a non-digit character"], 'do_td]>], 'do_tr]>], 'do_table]>], 'do_dfn]>, <$format, ["p", [], [], 'do_p]>, <$format, ["i", [], ["Note: the above escape characters have not yet been integrated into the regular expression matcher."], 'do_i]>], #[]]>;
var $help_node index = $help_index_driver;
var $help_node links = #[];
var $help_node nolist = 0;
var $root created_on = 854058118;
var $root flags = ['variables, 'methods, 'code, 'core];
var $root inited = 1;
var $root managed = [$help_coldc_regexp];
var $root manager = $help_coldc_regexp;


